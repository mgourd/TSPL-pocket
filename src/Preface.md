Preface
=======

Scheme was introduced in 1975 by Gerald J. Sussman and
Guy L. Steele Jr. [[28](bibliography.html#g246),[29](bibliography.html#g247)],
and was the first dialect of Lisp to fully support lexical scoping,
first-class procedures, and continuations. In its earliest form it was a
small language intended primarily for research and teaching, supporting
only a handful of predefined syntactic forms and procedures. Scheme is
now a complete general-purpose programming language, though it still
derives its power from a small set of key concepts. Early
implementations of the language were interpreter-based and slow, but
some current Scheme implementations boast sophisticated compilers that
generate code on par with code generated by the best optimizing
compilers for lower-level languages such as C and Fortran.

This book is intended to provide an introduction to the Scheme
programming language but not an introduction to programming in general.
The reader is expected to have had some experience programming and to be
familiar with terms commonly associated with computers and programming
languages. Readers unfamiliar with Scheme or Lisp should also consider
reading *The Little Schemer* [[13](bibliography.html#g231)] to become
familiar with the concepts of list processing and recursion. Readers new
to programming should begin with an introductory text on programming.

Scheme has been standardized both formally and informally. The *IEEE
Standard for the Scheme Programming
Language* [[18](bibliography.html#g236)], describes a formal ANSI/IEEE
Standard for Scheme but dates back to 1991. A related series of reports,
the "Revised Reports on the Algorithmic Language Scheme," document an
evolving informal standard that most implementations support. The
current report in this series is the "Revised^6^ Report on the
Algorithmic Language Scheme" [[24](bibliography.html#g242)], which was
completed in 2007.

This book covers the language of the Revised^6^ Report. It is not
intended to supplant the Revised^6^ Report but rather to provide a more
comprehensive introduction and reference manual for the language, with
more explanatory text and examples, suitable more for users than for
implementors. Features specific to particular implementations of Scheme
are not included. In particular, features specific to the author's
Chez Scheme and Petite Chez Scheme implementations are described
separately in the *Chez Scheme User's
Guide* [[9](bibliography.html#g227)]. On the other hand, no book on
Scheme would be complete without some coverage of the interactive top
level, since nearly every Scheme system supports interactive use in one
form or another, even though the behavior is not standardized by the
Revised^6^ Report. Chapters 2 and 3 are thus written assuming that the
reader has available a Scheme implementation that supports an
interactive top level, with behavior consistent with the description of
the top-level environment in earlier reports and the IEEE/ANSI standard.

A large number of small- to medium-sized examples are spread throughout
the text, and one entire chapter is dedicated to the presentation of a
set of longer examples. Many of the examples show how a standard Scheme
syntactic form or procedure might be implemented; others implement
useful extensions. All of the examples can be entered directly from the
keyboard into an interactive Scheme session.

This book is organized into twelve chapters, plus back matter.
Chapter [1](intro.html#g0) describes the properties and features of
Scheme that make it a useful and enjoyable language to use.
Chapter [1](intro.html#g0) also describes Scheme's notational
conventions and the typographical conventions employed in this book.

Chapter [2](start.html#g4) is an introduction to Scheme programming for
the novice Scheme programmer that leads the reader through a series of
examples, beginning with simple Scheme expressions and working toward
progressively more difficult ones. Each section of
Chapter [2](start.html#g4) introduces a small set of related features,
and the end of each section contains a set of exercises for further
practice. The reader will learn the most from Chapter [2](start.html#g4)
by sitting at the keyboard and typing in the examples and trying the
exercises.

Chapter [3](further.html#g49) continues the introduction but covers more
advanced features and concepts. Even readers with prior Scheme
experience may wish to work through the examples and exercises found
there.

Chapters [4](binding.html#g88) through [11](exceptions.html#g147) make
up the reference portion of the text. They present each of Scheme's
primitive procedures and syntactic forms in turn, grouping them into
short sections of related procedures and forms.
Chapter [4](binding.html#g88) describes operations for creating
procedures and variable bindings; Chapter [5](control.html#g96), program
control operations; Chapter [6](objects.html#g106), operations on the
various object types (including lists, numbers, and strings);
Chapter [7](io.html#g121), input and output operations;
Chapter [8](syntax.html#g133), syntactic extension;
Chapter [9](records.html#g138), record-type definitions;
Chapter [10](libraries.html#g142), libraries and top-level programs; and
Chapter [11](exceptions.html#g147), exceptions and conditions.

Chapter [12](examples.html#g151) contains a collection of example
procedures, libraries, and programs, each with a short overview, some
examples of its use, the implementation with brief explanation, and a
set of exercises for further work. Each of these programs demonstrates a
particular set of features, and together they illustrate an appropriate
style for programming in Scheme.

Following Chapter [12](examples.html#g151) are bibliographical
references, answers to selected exercises, a detailed description of the
formal syntax of Scheme programs and data, a concise summary of Scheme
syntactic forms and procedures, and the index. The summary of forms and
procedures is a useful first stop for programmers unsure of the
structure of a syntactic form or the arguments expected by a primitive
procedure. The page numbers appearing in the summary of forms and
procedures and the italicized page numbers appearing in the index
indicate the locations in the text where forms and procedures are
defined.

Because the reference portion describes a number of aspects of the
language not covered by the introductory chapters along with a number of
interesting short examples, most readers will find it profitable to read
through most of the material to become familiar with each feature and
how it relates to other features. Chapter [6](objects.html#g106) is
lengthy, however, and may be skimmed and later referenced as needed.

An online version of this book is available at
*http://www.scheme.com/tspl/*. The summary of forms and index in the
online edition include page numbers for the printed version and are thus
useful as searchable indexes.

*About the illustrations:* The cover illustration and the illustration
at the front of each chapter are algorithmic line fields created by
artist Jean-Pierre Hébert, based on an idea inspired by the writings of
John Cage. Each line field is created by the composition of any number
of grids of parallel lines. The grids are regular, but they are not. For
instance, the lines are of irregular length, which creates ragged edges.
Their tone and thickness vary slightly. They are not exactly
equidistant. They intersect with each other at a certain angle. When
this angle is small, patterns of interference develop. The lines are
first steeped into various scalar fields that perturb their original
straight shape, then projected on the plane of the paper. Masks
introduce holes in some layers. For the cover illustration, the grids
are colored in different hues.

All the images are created by a single Scheme program that makes most of
the decisions, based heavily on chance. The artist controls only canvas
size, aspect ratio, the overall palette of colors, and levels of chance
and fuzziness. The task of the artist is to introduce just enough chance
at the right place so that the results are at the same time surprising,
interesting, and in line with the artist's sense of aesthetics. This is
a game of uncertainty, chaos, and harmony.

*Acknowledgments:* Many individuals contributed in one way or another to
the preparation of one or more editions of this book, including Bruce
Smith, Eugene Kohlbecker, Matthias Felleisen, Dan Friedman, Bruce Duba,
Phil Dybvig, Guy Steele, Bob Hieb, Chris Haynes, Dave Plaisted, Joan
Curry, Frank Silbermann, Pavel Curtis, John Wait, Carl Bruggeman, Sam
Daniel, Oscar Waddell, Mike Ashley, John LaLonde, John Zuckerman, John
Simmons, Bob Prior, Bob Burger, and Aziz Ghuloum. Many others have
offered minor corrections and suggestions. Oscar Waddell helped create
the typesetting system used to format the printed and online versions of
this book. A small amount of text and a few examples have been adapted
from the Revised^6^ Report for this book, for which credit goes to the
editors of that report and many others who contributed to it. Finally
and most importantly, my wife, Susan Dybvig, suggested that I write this
book in the first place and lent her expertise and assistance to the
production and publication of this and the previous editions.

* * * * *

R. Kent Dybvig / The Scheme Programming Language, Fourth Edition\
 Copyright © 2009 [The MIT
Press](http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984).
Electronically reproduced by permission.\
 Illustrations © 2009 [Jean-Pierre
Hébert](http://hebert.kitp.ucsb.edu/)\
 ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93\
 [to order this
book](http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984)
/ [about this book](canned/about.html)

[http://www.scheme.com](http://www.scheme.com)
